---
title: "MA end to tend workflow"
author: "Bernd Klaus"
output: 
    BiocStyle::html_document:
        toc: true
        highlight: tango
vignette: >
    %\VignetteIndexEntry{dummy workflow to trace genefinder bug}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}  
---


<!--
To compile this document
graphics.off();rm(list=ls());rmarkdown::render('dummy-Workflow.Rmd');
-->

```{r options, include=FALSE}
library(knitr)
options(digits=3, width=80)
opts_chunk$set(echo=TRUE,tidy=FALSE,include=TRUE,
               dev='png', fig.width = 6, fig.height = 3.5, comment = '  ', dpi = 300,
cache = TRUE)
```



# Required packages and other preparations




```{r required packages and data, echo = TRUE}
library(BiocStyle)
library(oligo)
library(geneplotter)
library(ggplot2)
library(dplyr)
library(LSD)
library(gplots)
library(RColorBrewer)
library(ArrayExpress)
library(arrayQualityMetrics)
library(stringr)
library(matrixStats)
library(topGO)
library(genefilter)
library(biomaRt)
library(pd.hugene.1.0.st.v1)
library(hugene10sttranscriptcluster.db)
library(pheatmap)
library(mvtnorm)
library(DAAG)
library(multcomp)
library(limma)
library(EnrichmentBrowser)
library(xlsx)
library(devtools)
library(biomaRt)

rawDataDir <- file.path(getwd(), "rawDataMAWorkflow")
```


# Download the raw data from from ArrayExpress

The first step of the analysis is to download the raw data CEL files. Theses files
are produced by the array scanner software and contain the probe intensities 
measured. The data has been deposited at [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/)
and has the accession code **E-MTAB-2967**. This accession code is commonly
reported in the original publication. 

Each Array--Express data set has a landing page summarizing the data set, 
the one for our data is here:

* [Data fromPalmieri et. al. at ArrayEpress](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2967/)

We use the `r Biocpkg("ArrayExpress") ` Bioconductor package to obtain the links to
download the raw data.

# Information stored in ArrayExpress

In the repository for each dataset ArrayExpress stores a MAGE-TAB document with standardized
format. A MAGE-TAB document contains upt to five different types of files
Investigation DescriptionFormat (IDF), Array Design Format (ADF),
Sample and Data Relationship Format (SDRF), the raw data files and
the processed data files.

The Investigation Description Format (IDF) file contains top level information
about the experiment including title, description, submitter contact details and
protocols. The SDRF (Sample and Data Relationship Format) file containes
the information on the samples. 




# Get the raw and the annotation data 

Wih the code below, we download the raw data from
[ArrayExpress](https://www.ebi.ac.uk/arrayexpress/).

It is saved in the directory **rawDataDir** which defaults to the current
working directory. The names of the downloaded files are returned as a list.

```{r getDataEBI, eval=TRUE }
rawDataDir <- rawDataDir

if(!dir.exists(rawDataDir)){

    dir.create(rawDataDir)
}

annoAE <- getAE("E-MTAB-2967", path=rawDataDir, type="raw")
```

We now download the SDRF file directly to
in order to obtain the sample annotation.

The raw data constists of one CEL file per samples (see below) and
we use the .CEL file names as row names. They are given in a column
named `Array.Data.File` in the SDRF table. We turn the table into an
` AnnotatedDataFrame ` from the `r Biocpkg("Biobase") ` package that 
will need later to create an `ExpressionSet` for our data.


```{r getSDRF}
SDRF <-  read.delim(url("http://www.ebi.ac.uk/arrayexpress/files/E-MTAB-2967/E-MTAB-2967.sdrf.txt"),
                    row.names = "Array.Data.File")
SDRF <- AnnotatedDataFrame(SDRF)
```


Before we move on to the actual data import, we ill briefly introduce this
` ExpressionSet ` class contained in the `r Biocpkg("Biobase")` package.
It is commonly used to store Micorarray data in Bioconductor.

## Import of microarray data and initial quality control

### Importing CEL files
The microrarray analysis of Affymetrix arrays starts with CEL files. These are the result
of processing of the raw image files using the Affymetrix software and contain
estimated probe intensity values. Each CEL file contains data on the intensity at each
probe on the chip, as well as some other quantities.
We collect the information about the CEL files
we want to import and then save them in  the variable `rawData`.

The followng code results in a character vector with the paths to the
CEL files we want to import. the function ` read.celfiles `
from the `r Biocpkg("oligo") ` can be
used to import the files. The package automatically uses
`r  Biocannopkg("pd.hugene.1.0.st") ` as the chip annotation package.

We specifiy our `AnnotatedDataFrame` created earlier as `phenoData` and check
whether the object created is valid. (e.g. sample names match between the different
tables)

```{r importCelfiles, results="hide", eval=TRUE, dependson="getSDRF"}
celfolder <- rawDataDir
cels <- list.celfiles(path = celfolder, pattern="*.CEL")

rawData <- read.celfiles(filenames = file.path(rawDataDir, cels),
                         verbose = FALSE, phenoData = SDRF)

validObject(rawData)
```

We now inspect the raw data a bit, remove some uninteresting phenoData columns 
and finally retain only those columns that are related to the experimental factors.
(IDs of the individuals, disease of the individual and the mucosa type)

```{r inspectPhenoData, results='hide', eval=TRUE }
head(pData(rawData))
head(exprs(rawData))
stopifnot(validObject(rawData))

pData(rawData) <- pData(rawData)[, c("Source.Name",
                                     "Characteristics.individual.",
                                     "Factor.Value.disease.",
                                     "Factor.Value.phenotype." )]
```


The `r Biocpkg("arrayQualityMetrics") ` report shows that the second principal
component seems to differentiate  between the diseases. The density-- and
boxplots show that the  intensity distributions
of the individual arrays are quite different, indicating the need of an appropriate
normalization, which we will discuss next.


Basend on the PCA plot we remove the arrays belonging to individuals 255, 2209,
2826, 3262, 3302 and 3332 since arrays that are based on tissues from them have been
identified as outliers by at least one method or have an unusual intensity
distribution (255 and 2209) compared to the other arrays.


```{r removeOutliers, dependson="inspectPhenoData"}
outlierIdx <- pData(rawData)$Characteristics.individual. %in% c( 255, 2209,
                                                                  2826, 3262,
                                                                  3302,3332)
table(outlierIdx)

rawData <- rawData[, !outlierIdx ]
```


You can view its content like this

```{r annotation data base content, eval = TRUE}
head(ls("package:hugene10sttranscriptcluster.db"))
```



## One--go preprocessing in oligo
`r Biocpkg("oligo") ` allows us to perform background correction, normalization
and summarization in one single step using a deconvolution method for
background correction, quantile normalization and
the RMA (robust multichip average) algorithm for summarization.

This package of algorithms as a whole is commonly called RMA algorithm,
although strictly speaking RMA is only a summarization method.

```{r RMAcalibration, eval=TRUE}
palmieriEset <- oligo::rma(rawData, target="core")

stopifnot(isTRUE(identical(featureNames(palmieriEset)[c(500, 5500)], 
                           c("7893003", "7909954"))))

#save(palmieriEset, file = "palmieriEset.RData")
```

## Filtering based on intensity 
We now filter out lowly expressed genes. Microarrays commonly show a large number
of probes in the background range. They do not change much and have a low
intensity. Hence they combine a low variance with
a low intensity. Thus they could end up as being detected as differentially
expressed although they are barely above the "detection" limit. We will perform
a "soft" intensity based filtering here, since this is recommended by
the `r Biocpkg("limma") ` although a variance based filter might filter a similar
set of probes in practice. We filter low gene
medians by visually inspecting fitting a "null" distribution
$0.05 \cdot N(5.1, 1.18)$ of the gene--wise medians representing their typical
behavior.

Then we use the 5% quantile of this distribution as a threshold. We keep
only those genes that show an expression higher than threshold in at least
as many arrays as in  the smallest experimental group.

```{r expGroups, dependson="PCAMetricsCalibrated"}
table(pData(palmieriEset)$Factor.Value.disease.)
```

In our case this would be \Sexpr{table(pData(palmieriEset)$Factor.Value.disease.)[1]}.


```{r intensityBasedFiltering, fig.width=10, fig.height=6, eval=TRUE}
PalmieriMedians <- rowMedians(exprs(palmieriEset))
tmp <- hist(PalmieriMedians, 100, col="lavender", freq = FALSE)

emp_mu <- tmp$breaks[which.max(tmp$density)]
emp_sd <- mad(PalmieriMedians)/2
eta0 <- 0.50

lines(sort(PalmieriMedians), eta0*dnorm(sort(PalmieriMedians),
  			mean = emp_mu , sd = emp_sd ),
				col = "darkorange", lwd =4)

### find 5% quantile of fitted null model
cut_val <- 0.05 / eta0
thresh_median <- qnorm(0.05 / eta0, emp_mu, emp_sd)


noOfSamples <- table(pData(palmieriEset)$Factor.Value.disease.)[1]
idx_thresh_median <- apply(exprs(palmieriEset), 1, function(x){
	sum(x > thresh_median)  >  noOfSamples
    })
    table( idx_thresh_median)


PalmieriFiltered <- subset(palmieriEset, idx_thresh_median )
```



## Annotation of the transcript clusters

Before we continue with the linear models for microarrays and differential
expression  we  describe how to add ``feature Data", i.e. annotation
information to the transcript clusters. We use the \Rfunction{select}
from `r Biocpkg("AnnotationDbi") ` to query the gene symbols and associated
short descriptions for the transcript clusters.


```{r annotateData, eval=TRUE, dependson="intensityBasedFiltering", message = FALSE}
annoPalmieri <- AnnotationDbi::select(hugene10sttranscriptcluster.db,
                                  keys=(featureNames(PalmieriFiltered)),
                                  columns = c("SYMBOL", "GENENAME"),
                                  keytype="PROBEID")
message(c("length of featue names: ", length(featureNames(PalmieriFiltered))))
message(paste(dim(annoPalmieri), collapse = "--"))

message(paste(annoPalmieri[19106,], collapse = "--"))
# "8056784--DLX2--distal-less homeobox 2"
stopifnot(dim(annoPalmieri) == c( 31589, 3))
```



## Removing multiple mappings and building custom annotations

Many transcript--cluster IDs will map to multiple gene symbols.
We compute a summary table in the code below to see how many there are.

```{r multipleMappings, dependson="annotateData"}

probeStats <- annoPalmieri  %>%
    group_by(PROBEID) %>%
    summarize(noOfMatches = n_distinct(SYMBOL)) %>%
    filter( noOfMatches > 1)

probeStats

dim(probeStats)

```

We have  over 2000 transcript--clusters that map to multiple gene symbols.
It is diffcult to decide which mapping is "correct". Therefore,
we exclude these transcript--clusters. Additionally, we also exclude
transcript--clusters that do not map to gene symbols.


```{r excludeMultipleMappings, dependson="multipleMappings"}

IDsToExlude <- ((featureNames(PalmieriFiltered) %in% probeStats$PROBEID) |
               featureNames(PalmieriFiltered)  %in% subset(annoPalmieri,
                                                           is.na(SYMBOL))$PROBEID)
table(IDsToExlude)

PalmieriFinal <- subset(PalmieriFiltered, !IDsToExlude )

validObject(PalmieriFinal)

fData(PalmieriFinal)$PROBEID <- rownames(fData(PalmieriFinal))
fData(PalmieriFinal) <- left_join(fData(PalmieriFinal), annoPalmieri)

# restore rownames
rownames(fData(PalmieriFinal)) <-fData(PalmieriFinal)$PROBEID 
    
#table(rownames(fData(PalmieriFinal)) == rownames(exprs(PalmieriFinal)))

validObject(PalmieriFinal)
#save(PalmieriFinal, file = "PalmieriFinal.RData")

```


# Gene ontology enrichment analysis


```{r GOAnalysisCreateBackgrounds, eval=TRUE, warning=FALSE}


individual <- as.character(pData(PalmieriFinal)$Characteristics.individual.)

tissue <- str_replace_all(pData(PalmieriFinal)$Factor.Value.phenotype., " ", "_")
tissue <- ifelse(tissue == "non-inflamed_colonic_mucosa", "nI", "I")

disease <- str_replace_all(pData(PalmieriFinal)$Factor.Value.disease., " ", "_")
disease <- ifelse(disease == "Crohn's_disease", "C", "U")


i <- individual[disease == "C"]
designPalmieriC <- model.matrix(~ 0  + tissue[disease == "C"]
                                + i)
colnames(designPalmieriC)[1:2] <- c("I", "nI")


contrastMatrixC <- makeContrasts(I-nI, levels = designPalmieriC)

PalmieriFitC <- eBayes(contrasts.fit(lmFit(PalmieriFinal[,disease == "C"],
                                design = designPalmieriC),
                                contrastMatrixC))
tableC <-  topTable(PalmieriFitC, number = Inf)
#write.csv(tableC, file = "tableC.csv")

#rm(tableC)

#tableC <- read.csv("tableC.csv", row.names  = 1)
DEgenesCD <- base::subset(tableC, adj.P.Val < 0.1)$PROBEID

message(paste0(as.character(DEgenesCD)[1:5], collapse = "--"))

backGIdx <- genefinder(PalmieriFinal, as.character(DEgenesCD)[1:5], 
                       method="manhattan", scale="none")

```






