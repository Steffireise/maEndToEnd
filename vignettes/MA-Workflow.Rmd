---
title: "An end to end workflow for differential gene expression using Affymetrix microarrays"
author: 
  - name: Bernd Klaus
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, bernd.klaus@embl.de
  - name: Stefanie Reisenauer
    affiliation: EMBL Heidelberg, Meyerhofstrasse 1, 69117 Heidelberg, Germany, stefanie.reisenauer@embl.de
abstract: In this article, we walk through an end--to--end Affymetrix microarray differential expression workflow using Bioconductor packages. This workflow is directly applicable to current "Gene" type arrays, e.g. the HuGene or MoGene arraysbut can easily be adapted to  similar platforms. The data re--analyzed is a typical clinical microarray data set that compares inflamed and non--inflamed colon tissue in two disease subtypes. For each disease, the differential gene expression between inflamed-- and non--inflamed colon tissue was analyzed. We will start from the raw data CEL files, show how to import them into a Bioconductor ExpressionSet, perform quality control and normalization and finally differential gene expression (DE) analysis, followed by some enrichment analysis.
keywords: Microarry, Gene Expression
bibliography: MAEndToEnd.bib
output:
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
csl: f1000-research.csl

vignette: >
  %\VignetteIndexEntry{An end to end workflow for differential gene expression using Affymetrix microarrays}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

<!--Html rendering for Bioc Workflow using BiocStyle-->
<!-- rmarkdown::render("MA-Workflow.Rmd") -->


<!-- pdf rendering using to F1000 template from Mike's BiocWorkflowTools  -->
<!-- rmarkdown::render("MA-Workflow.Rmd",
output_format = BiocWorkflowTools::f1000_article()) -->


<!--  Conversions between f1000 / BioStyle by Leo Torres -->
<!-- https://stat.ethz.ch/pipermail/bioc-devel/2018-April/013237.html -->
<!-- His example recount workflow that compiles to both BioC and F1000  -->
<!-- https://github.com/LieberInstitute/recountWorkflow/blob/master/vignettes/recount-workflow.Rmd -->


```{r biocSetup, include = FALSE, results="hide", warning=FALSE, echo=FALSE}
## Changing the YAML to the following changes the output to 'latex'
## output:
##   BiocWorkflowTools::f1000_article
## More at:
## https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word

## here, pdf specific adapations can be made
## on.bioc <- knitr::opts_knit$get("rmarkdown.pandoc.to") != 'latex'
#knitr::opts_chunk$set(fig.path = "")
suppressPackageStartupMessages({library("maEndToEnd")})

```



```{r knitrOptions, include=FALSE}
library(BiocStyle)
library(knitr)
options(digits = 3, width = 80)
opts_chunk$set(echo=TRUE, 
               tidy=FALSE, 
               include=TRUE,
               dev=c('png', 'pdf'),
               fig.width = 6, fig.height = 3.5,
               comment = '  ', 
               dpi = 300, cache=TRUE)
```


<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocInstaller::biocVersion()`
<br />
**Package version**: `r packageVersion("maEndToEnd")`
</p>


# Introduction

In this article we introduce a complete workflow for a typical (Affymetrix) microarray
analysis. Data import, preprocessing, differential expression  and
enrichment analysis are discussed. We also introduce some necessary mathematical
background on linear models along the way. <!-- SR: tbd whether "we introduce some necessary mathematical background on linear models along the way" -->

The data set used [@Palmieri_2015] is from a paper studying the differences in gene expression in inflamed-- and non--inflamed tissue. 
14 Patients suffering from Ulcerative colitis (UC) and 15 patients with Crohn's disease (CD) were tested, and from each patient inflamed-- and non--inflamed colonic mucosa tissue was obtained via a biopsy. 
This is a typical clinical data set consisting of 58 probes in total.
Our aim is to analyze differential expression (DE) between the tissues. As a proof of concept, we compare our results to the ones found in the paper. 

# Required packages and other preparations

```{r, echo=FALSE, results="hide", warning=FALSE, eval=TRUE}
suppressPackageStartupMessages({
    library("maEndToEnd")
})
```

```{r pkgList}
library(BiocStyle)
library(oligo)
library(geneplotter)
library(ggplot2)
library(dplyr)
library(LSD)
library(gplots)
library(RColorBrewer)
library(ArrayExpress)
library(arrayQualityMetrics)
library(stringr)
library(matrixStats)
library(topGO)
library(genefilter)
library(biomaRt)
library(pd.hugene.1.0.st.v1)
library(hugene10sttranscriptcluster.db)
library(pheatmap)
library(mvtnorm)
library(DAAG)
library(multcomp)
library(limma)
library(ReactomePA)
library(clusterProfiler)
library(openxlsx)
library(devtools)
library(biomaRt)

```


# Download the raw data from from ArrayExpress

The first step of the analysis is to download the raw data CEL files. These files
are produced by the array scanner software and contain the probe intensities 
measured. The data we use have been deposited at [ArrayExpress](https://www.ebi.ac.uk/arrayexpress/)
and have the accession code **E-MTAB-2967**.

We will store these files in the directory **raw\_data\_dir** which defaults to the subdirectory
`rawDataMAWorkflow` of the current working directory:

```{r generateFolderForRawData, echo = TRUE}
raw_data_dir <- file.path(getwd(), "rawDataMAWorkflow")

if(!dir.exists(raw_data_dir)){
    dir.create(raw_data_dir)
}
```


Each ArrayExpress data set has a landing page summarizing the data set, 
and we use the `r Biocpkg("ArrayExpress") ` Bioconductor package to obtain the ftp 
links  to the raw data files ([Data from Palmieri et. al. on ArrayEpress](https://www.ebi.ac.uk/arrayexpress/experiments/E-MTAB-2967/)).

<!--SR: what do we need this information for? --> 

# Information stored in ArrayExpress

Each dataset at ArrayExpress is stored according to the MAGE--TAB 
(MicroArray Gene Expression Tabular) specifications as a collection of
tables bundled with the raw data. The MAGE--TAB format specifies  up to five 
different types  of files, namely the
Investigation Description Format (IDF), the Array Design Format (ADF),
the Sample and Data Relationship Format (SDRF), the raw data files and
the processed data files.

Other than the raw data files, the IDF and the SDRF file are important for us. 
The IDF file contains top level information
about the experiment including title, description, submitter contact details and
protocols. The SDRF file contains essential information on the experimental 
samples, e.g. the experimental group(s) they belong to. 
<!-- SR: is it possible that we never use the IDF file again? We never import it, right? --> 
# Download the raw data and the annotation data 

With the code below, we download the raw data from
[ArrayExpress](https://www.ebi.ac.uk/arrayexpress/) [@Kolesnikov_2014] by using the getAE-function.
The data are saved in the `raw_data_dir` created above. The names of the downloaded files are returned as a list.


```{r getDataEBI, eval=TRUE, results='hide', message=FALSE}

anno_AE <- getAE("E-MTAB-2967", path=raw_data_dir, type="raw")
```

We now import the SDRF file from the raw data folder in order to obtain the sample annotation with the `read.delim` function. 

The raw data consists of one CEL file per sample (see below) and
we use the CEL file names, thus the sample identifiers, as row names for the imported SDRF data. 

These names are given in a column named `Array.Data.File` in the SDRF table. We turn the SDRF table into an `AnnotatedDataFrame` from the `r Biocpkg("Biobase")` package that we
will need later to create an `ExpressionSet` for our data [@Bioc].

```{r getSDRF from local directory}
sdrf_location <- file.path(raw_data_dir, "E-MTAB-2967.sdrf.txt")
SDRF <- read.delim(sdrf_location)

rownames(SDRF) <- SDRF$Array.Data.File
SDRF <- AnnotatedDataFrame(SDRF)
```

Before we move on to the actual raw data import, we will briefly introduce the
`ExpressionSet` class contained in the `r Biocpkg("Biobase")` package.
It is commonly used to store microarray data in Bioconductor.

## Bioconductor ExpressionSets

Genomic data can be very complex,
usually consisting of a number of different bits and pieces, e.g. information
on the experimental samples, annotation of genomic features measured as well
as the experimental data itself.
In Bioconductor the approach is taken that these  pieces should be stored in
a single structure to easily manage the data.

The package `r Biocpkg("Biobase")` contains standardized data structures
to represent genomic data. The `ExpressionSet` class is designed
to combine several different sources of information (i.e. as contained in the 
various MAGE--TAB files) into a single convenient
structure. An ExpressionSet can be manipulated (e.g., subsetted, copied),
and is the input to or output of many Bioconductor functions.

The data in an ExpressionSet consist of

+ **assayData**: Expression data from microarray experiments.

+ **metaData**: A description of the samples in the experiment
(phenoData), metadata about the features on the chip or technology used for the
experiment (featureData), and further annotations for the features, for example
gene annotations from biomedical databases (annotation).

+ **experimentData**: A flexible structure to describe the experiment.

The ExpressionSet class coordinates all of these data, so that one does not 
have to worry about the details. However, some constraints have to be met. 
In particular, the rownames of the `phenoData` (which holds the content of the
SDRF file) have to match the column names of the assay data (as they represent the sample
identifiers), while the row names of the assay data have to match the 
row names of the `featureData` (as they represent the feature identifiers). This is 
illustrated in the figure.

<!-- SR: muss man jemals selbst etwas machen, um diese Zeilen/Spalten-Übereinstimmungen aufrecht zu erhalten? -> nachher beim left-join, nachdem man multiple mappings rausgefiltert hat, aber: das versteht man hier noch nicht, finde ich; man kann mit dem Begriff "feature" noch nichts anfangen -->

```{r sumexpOld, echo=FALSE, fig.show="asis"}
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0,100),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
polygon(c(45,80,80,45),c(10,10,70,70),col=rgb(1,0,0,.5),border=NA)
polygon(c(45,80,80,45),c(68,68,70,70),col=rgb(1,0,0,.5),border=NA)
text(62.5,40,"assay(s)", cex = 1)
text(62.5,30,"e.g. 'exprs'", cex = 1)
polygon(c(20,40,40,20),c(10,10,70,70),col=rgb(0,0,1,.5),border=NA)
polygon(c(20,40,40,20),c(68,68,70,70),col=rgb(0,0,1,.5),border=NA)
text(30,40,"featureData", cex = 1)
polygon(c(45,80,80,45),c(75,75,90,90),col=rgb(.5,0,.5,.5),border=NA)
polygon(c(45,47,47,45),c(75,75,90,90),col=rgb(.5,0,.5,.5),border=NA)
text(62.5,82.5,"phenoData", cex = 1)
```

<!-- SR: die Grafik finde ich nicht verständlich; eigentlich sollen ja Zeilen von phenoData mit Spalten von assayData übereinstimmen, aber bei pheno is eine Spalte markiert und bei assay eine Zeile? feature- und Assay-Data macht sinn, weil hier jeweils eine Zeile markiert ist. -> Vorschlag:--> 

```{r sumexp, fig.cap = "Structure of Bioconductor’s ExpressionSet class.", echo=FALSE, fig.show="asis"}
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 150),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")

polygon(c(45,80,80,45),c(70,70,130,130),col=rgb(1,0,0,.5),border=NA)
polygon(c(45,80,80,45),c(128,128,130,130),col=rgb(1,0,0,.5),border=NA)
polygon(c(45,46.5, 46.5, 45),c(70,70,130,130),col=rgb(1,0,0,.5),border=NA)
text(62.5,100,"assay(s)", cex = 1)
text(62.5,90,"e.g. 'exprs'", cex = 1)

polygon(c(20,40,40,20),c(70,70,130,130),col=rgb(0,0,1,.5),border=NA)
polygon(c(20,40,40,20),c(128,128,130,130),col=rgb(0,0,1,.5),border=NA)
text(30,100,"featureData", cex = 1)

polygon(c(45,60, 60, 45),c(60, 60, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
polygon(c(45,46.5, 46.5, 45),c(60, 60, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
text(52.5, 30,"phenoData", cex = 1, srt=90)
```

You can use the functions ` pData ` and ` fData ` to extract
the sample and feature annotation respectively from an ` ExpressionSet `.
The function ` exprs ` will return the expression data itself as a matrix.

## Import of the raw microarray data 

In the first step of the analysis, we create the Expression Set "raw_data", which contains array data, pheno data (from the SDRF file) as well as the information of the correct chip annotation package to use.


The analysis of Affymetrix arrays starts with CEL files. These are the result
of the processing of the raw image files using the Affymetrix software and contain
estimated probe intensity values. Each CEL file additionally contains some 
metadata, such as a chip identifier. 

We use the function ` read.celfiles`  from the `r Biocpkg("oligo") ` package [@oligo] to import the files. This automatically creates an ExpressionSet, fills the sections "array data" with the data from the CEL files and uses the correct chip annotation package, in this case
`r  Biocannopkg("pd.hugene.1.0.st.v1") `, as the 
chip--type is also stored in the .CEL files. 
Further, We specify our `AnnotatedDataFrame` created earlier from the SDRF file as `phenoData`. Thus, We have to be sure that we import the CEL files in the order that corresponds to the SDRF
table --- to enforce this, we use the column `Array.Data.File` of the `SDRF` table as the `filenames` argument.

Finally, we check whether the object created is valid (e.g. sample names 
match between the different tables).

We collect the information about the CEL files and import them into the variable `raw_data`:


```{r importCelfiles, results="hide", eval=TRUE, dependson="getSDRF", warning = FALSE }
raw_data <- oligo::read.celfiles(filenames = file.path(raw_data_dir, 
                                                SDRF$Array.Data.File),
                         verbose = FALSE, phenoData = SDRF)
validObject(raw_data)
```

We now inspect the raw data a bit and retain only those columns that are 
related to the experimental factors of interest.

The pData function of the Biobase package directly accesses the "data" subfolder in the phenoData tab in the table bundle <!--SR: expression set? --> "raw_data". With the `head()` function, we can view the first six lines of the table. 


```{r inspectPhenoData, eval=TRUE }
head(Biobase::pData(raw_data))
head(exprs(raw_data))
stopifnot(validObject(raw_data))
```

The columns of interest for us are the following:
**identifiers of the individuals, i.e. columns "Source.Name, "Characteristics.individual."
**disease of the individual, i.e. "Factor.Value.disease."
**mucosa type, i.e. "Factor.Value.phenotype."

We reassign the `Biobase::pData(raw_data)`function to the corresponding columns: 

```{r reassignpData, eval=TRUE}
Biobase::pData(raw_data) <- Biobase::pData(raw_data)[, c("Source.Name",
                                     "Characteristics.individual.",
                                     "Factor.Value.disease.",
                                     "Factor.Value.phenotype.")]
```


## Quality control of the raw data

The first step after the initial data import is the quality control of the data.
Here we check for outliers and try to see whether the data clusters as expected, 
e.g. by the experimental conditions. The expression intensity values are in the assayData subfolder "exprs" and can be accessed by the `exprs(raw_data)`function. The rows represent the microarray probes, that is the single DNA locations on the chip, while the columns represent one microarray, that is a sample of inflamed- and non-inflamed tissue of every patient, respectively. 
We take the log2 of `exprs(raw_data)`, as expression data is always analyzed on a logarithmic scale.
We then perform a principal component analysis (PCA) and plot it. Every point in the plot represents one sample, with the colour indicating the mucosa type (inflamed vs non-inflamed) and the shape indicating the disease (UC or CD).
We also plot a boxplot graph with boxes for the probe intensities on individual microarrays. Note that the `oligo::boxplot`function, i.e. the boxplot function of the oligo package, can take whole expression sets as argument. It accesses the expression data and performs a log2-transformation by default. We therefore can use `raw_data`as argument here.

```{r qualityControlRawDataPCA, fig.cap="PCA plot of the log–transformed raw data."}
exp_raw <- log2(exprs(raw_data))
PCA_raw <- prcomp(t(exp_raw), scale = FALSE)

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                    Disease = Biobase::pData(raw_data)$Factor.Value.disease.,
                    Phenotype = Biobase::pData(raw_data)$Factor.Value.phenotype.,
                    Individual = Biobase::pData(raw_data)$Characteristics.individual.)


(qplot(PC1, PC2, data = dataGG, color =  Phenotype, shape = Disease,
       main = "PCA plot of the raw data (log-transformed)", size = I(2), 
       asp = 1.0)
     + scale_colour_brewer(palette = "Set2"))





```

```{r qualityControlRawDataBox, fig.cap="Intensity boxplots of the log2–transformed raw data."}
oligo::boxplot(raw_data, target="core", main="Boxplot of log2-intensitites for the raw data")
```


The PCA (performed on the log--intensity scale) plot of the raw data shows 
that the first principal component differentiates  between the diseases. This means that the expression data mainly differs between the diseases. This might hinder our analysis, as we want to analyze the differential expression between inflamed- and non-inflamed tissue, independently of the disease a person has. When looking at the boxplot, we see that the  intensity distributions 
of the individual arrays are quite different,
indicating the need for an appropriate normalization, which we will discuss next.

Until now, we have only performed a very basic quality control; for more elaborate quality control plots, we could use the package `r Biocpkg("arrayQualityMetrics") ` [@AQM]. The package  produces an html report, containing the quality control plots together with a description of their
aims and an identification of possible outliers. We don't discuss this tool in detail
here, but the code below can be used to create a report for our raw data. 

```{r arrayQualityMetricsRaw, eval = FALSE}
arrayQualityMetrics(expressionset = raw_data,
    outdir = "Report_for_Palmieri_raw",
    force = TRUE, do.logtransform = TRUE,
    intgroup = c("Factor.Value.disease.", "Factor.Value.phenotype."))
```

# Background adjustment, calibration, summarization and annotation

## Background adjustment

After the initial import and quality assessment, the next step in processing of
microarray data is background adjustment. This is essential because a part of the
measured probe intensities are due to non-specific hybridization and the noise 
in the optical detection system. Therefore, observed intensities need to be adjusted to 
give accurate measurements of specific hybridization.

## Across--array normalization (calibration)

Without proper normalization across arrays, it is impossible to compare measurements from
different array hybridizations due to many obscuring sources of variation.
These include different efficiencies of
reverse transcription, labeling or hybridization
reactions, physical problems with the arrays, reagent batch effects, and laboratory
conditions. 

## Summarization

After normalization, summarization is needed because on the Affymetrix 
platform, transcripts are represented
by multiple probes, that is multiple locations on the array. For each gene, the background adjusted and normalized intensities of all probes
need to be summarized into one quantity that estimates an amount proportional to
the amount of RNA transcript.

After the summarization step, the summarized data can be annotated with various
information, e.g. gene symbols and ENSEMBL gene identifiers. There is an
annotation database available from Bioconductor 
for our platform, namely the package
`r Biocannopkg("hugene10sttranscriptcluster.db") `.

You can view its content like this

```{r annotationDataBaseContent, eval = TRUE}
head(ls("package:hugene10sttranscriptcluster.db"))
```

Additional information is available from the reference manual of the package.
Essentially, the package provides a mapping from the transcript cluster 
identifiers to the various annotation data.

## Old and new "probesets" of  Affymetrix microarrays

Traditionally, Affymetrix arrays (the so--called 3' IVT arrays)
were probeset based: a certain fixed group of probes were part of a probeset
which represented a certain gene or transcript (note however, that a
gene can be represented by multiple probesets).

The more recent "Gene" and "Exon" Affymetrix arrays are exon based and hence there 
are two levels of summarization to get on the gene level. The "probeset" summarization leads to the exon level. The gene/transcript level is given by "transcript clusters." Hence, the appropriate annotation package for our chip type is called
`r Biocpkg("hugene10sttranscriptcluster.db") `.

"Gene" arrays were created as affordable versions of the "Exon" arrays, by only taking the "good" probes from the Exon array. Initially on the exon array, at least four probes were part of one "Exon". With the thinned out "Gene" array, a lot of probesets were made up of three or fewer probes. Thus, a summarization on the probeset / exon level 
is not recommended for "Gene" arrays but nonetheless possible by using the 
`r Biocannopkg("hugene10stprobeset.db") ` annotation package.

Note that furthermore, there are also no longer designated match/mismatch probes present on "Gene" <!-- SR: and "Exon" type? --> type chips. The mismatch probe was initially intended as base-level for background correction, but didn't prevail due to more elaborate background correction techniques that didn't require a mismatch probe. 

## One--go preprocessing in oligo

The package `r Biocpkg("oligo") ` allows us to perform background correction, 
normalization and summarization in one single step using a deconvolution 
method for background correction, quantile normalization and
the RMA (robust multichip average) algorithm for summarization.

This series of steps as a whole is commonly referred to as RMA algorithm,
although strictly speaking RMA is merely a summarization method.
[@Irizarry_2003; @Bolstad_2003; @Irizarry_2003a].

#Relative Log Expression data quality analysis
Before calibrating and evaluating the data, we want to perform another means of quality control, namly Relative Log Expression box plots (RLE), as  escribed in the article by Gandolfo et al [@Gandolfo_2018]: To this goal, we first perform an RMA without normalization: 
```{r RMAcalibrationForRLE, eval=TRUE}
palmieri_eset <- oligo::rma(raw_data, target="core", normalize=FALSE)
```
Further details on the RMA algorithm will be provided after RLE analysis, when the "full" RMA is carried through, including normalization. 

The RLE is performed by calculating the median log2 intensity of one transcript across all arrays. We do this by calculating the row medians of `exprs(palmieri_eset)`, as the  transcripts are represented by the rows and the single microarrays by the columns. Note that we don't have take the log2 manually, as the output data of the RMA function is in log2 scale by default. 
We then substract this transcript median intensity from every transcript intensity, respectively, with the `sweep` function. 
We bring the data into a form in which we can plot a boxplot for each array, as before. Note that on the y-axis, we now see for each microarray the values of variation of expression intensity from the median of the single transcripts. 
Boxes with a larger extension in y scale therefore indicate an unusual high variation from the median in a lot of transcripts, suggesting decreased reliability of the data. Boxes that are shifted in y direction indicate a systematically higher or lower expression of the majority of transcripts in comparison to the other arrays, and thus also decreased data reliability. If shape and median of the single boxes vary too much from the others, it should be considered to remove the corresponding arrays. 

```{r boxplotDataForRLE}

row_medians_assayData <- rowMedians(as.matrix(exprs(palmieri_eset)))
RLE_data <- sweep(exprs(palmieri_eset), 1, row_medians_assayData)

#boxplot
RLE_data_trafo <- as.data.frame(t(RLE_data))
RLE_data_trafo$patient_probe <- rownames(RLE_data_trafo)
library("reshape2")
RLE_data_trafo.m <- melt(RLE_data_trafo, id.vars= "patient_probe")
RLE_data_trafo.m <- plyr::rename(RLE_data_trafo.m, c("value"="log2_expression_variation"))
ggplot(RLE_data_trafo.m, aes (patient_probe, log2_expression_variation)) + geom_boxplot(outlier.shape=NA) + ylim(c(-2, 2)) + theme(axis.text.x= element_text(colour="aquamarine4", angle=60, size=6.5, hjust=1, face="bold"))
```

When looking at the data, 5 arrays could be considered to be outliers: 2826_I, 2826_II, 3262_II, 3302_II and 3332_II are negatively y--shifted. We will keep these samples in mind for heatmap cluster analysis later on in the workflow. Arrays that are confirmed to be outliers by heatmap analysis can be removed for subsequent analysis.

Now, we can apply the full RMA algorithm to our data in order to background-correct, normalize and summarize:
```{r RMAcalibrationWITHnormalization, eval=TRUE}
palmieri_eset_norm <- oligo::rma(raw_data, target="core")
```

The parameter `target` defines the degree of summarization, the
default option of which is "core", using transcript clusters containing
"safely" annotated genes. Other options for `target` include "extended"
and "full". For summarization on the exon level (not recommended for Gene
arrays), one can use "probeset" as the target option.
Although other methods for background correction and normalization exist,
RMA is usually a good default choice.
RMA shares information across arrays and
uses the versatile quantile normalization method  that
will make the array intensity distributions match. However, it is preferable 
to apply it only after outliers have been removed. 
The quantile normalization algorithm used by RMA
works by replacing values by the average of identically
ranked (with a single chip) values across arrays. A more detailed 
description can be found on the [Wikipedia page](https://en.wikipedia.org/wiki/Quantile_normalization) 
about it.

An alternative to quantile normalization would be the `r Biocpkg("vsn") ` algorithm,
that performs background correction and normalization by robustly
shifting and scaling intensity values within arrays [@vsn] before log--transforming
them. This is less "severe" than quantile normalization. 

## Some mathematical background on normalization (calibration) and background correction

A generic model for the value of the intensity \(Y\) of a single probe on
a microarray is given by

$$
    Y = B + \alpha \cdot S
$$
    
where B is a random quantity due to background noise, usually composed of
optical effects and non-specific binding, \(\alpha\) is a gain factor, and \(S\)
is the amount of measured specific binding. The signal \(S\) is considered a
random variable as well and accounts for measurement error and probe effects.
The measurement error is typically assumed to be multiplicative so we can write:

$$
    \log(S) = \theta + \varphi + \varepsilon
$$
    
Here \(\theta\) represents the logarithm of the true abundance,
\(\varphi\) is a probe-specific effect, and $\varepsilon$ accounts for the 
nonspecific error.
This is the additive--multiplicative--error model for microarray data used by RMA
and also the `r Biocpkg("vsn") ` algorithm [@vsn]. The algorithms differ 
in the way that \(B\) is removed and an estimate of \(\theta\) is obtained.


## Quality assessment of the calibrated data

We now produce a clustering heatmap and another PCA plot using the calibrated data. 

### PCA analysis

First, we perform a PCA analysis of the calibrated data analogously to the one with the raw data:

```{r PCAMetricsCalibrated, fig.cap = "PCA plot of the calibrated data.", eval = TRUE }
exp_palmieri <- exprs(palmieri_eset_norm)
PCA <- prcomp(t(exp_palmieri), scale = FALSE)

dataGG <- data.frame(PC1 = PCA$x[,1], PC2 = PCA$x[,2],
                    Disease = Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.,
                    Phenotype = Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.)
        
(qplot(PC1, PC2, data = dataGG, color =  Phenotype, shape =  Disease,
       main = "PCA plot of the calibrated data", size = I(2), asp = 1.0)
       + scale_colour_brewer(palette = "Set2"))
```

In comparison to the first PCA analysis before RMA, we see that now the first principal component clusters between tissues types. This indicates that now differential expression between the tissue types can be analyzed quite well.

###Heatmap clustering analysis

In order to display a heatmap of the sample--to--sample distances, we first compute the distances using the `dist` function. We need to transpose the expression values since
the function computes the distances between the rows (i.e. genes in our case) by
default. The default distance  is the Euclidean one. However this can be
changed and we choose the Manhattan distance here (it uses absolute distances along rectangular paths instead of squared distances of the direct path), as it is more robust. We set the diagonal of the distance matrix to ` NA ` in order to increase the contrast of the color coding. Those diagonal entries do not contain information since the distance of a sample to itself is always equal to zero.
```{r rownamesForHeatmap, fig.height = 8.5, eval = TRUE, echo=FALSE}
phenotype_names <- c()
disease_names <- c()

for (i in 1:length(Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.)){
  if(grepl ("non", toString(Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.[i])))
    {phenotype_name="non-infl."}
  else {phenotype_name = "infl."}
  phenotype_names <- c(phenotype_names, phenotype_name)
  
  if (grepl ("Crohn", toString(Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.[i])))
    {disease_name="CD"}
  else {disease_name="UC"}
  disease_names <- c(disease_names, disease_name)
}

row_names_dataframe <- data.frame("Phenotype"=phenotype_names, "Disease"=disease_names)
row_names_for_heatmap <- paste(row_names_dataframe$Phenotype, row_names_dataframe$Disease, sep="   ")

```

```{r clusteringHeatmap, fig.cap = "Heatmap of the sample to sample distances for the calibrated data.", fig.height = 8.5, eval = TRUE }
dists <- as.matrix(dist(t(exp_palmieri), method = "manhattan"))
colnames(dists) <- NULL
diag(dists) <- NA
rownames(dists) <- row_names_for_heatmap
hmcol <- colorRampPalette(brewer.pal(9, "PuOr"))(255)

pheatmap(dists, col = (hmcol), legend=TRUE, legend_breaks=c(min(dists, na.rm=TRUE), max(dists, na.rm=TRUE)), legend_labels=(c("low difference", "high difference")))


```
<!-- SR: title for heatmap? --> 

On the heatmap plot we also see that the samples do not cluster strongly by tissue, confirming the impression from the PCA plot that the separation
between the tissues is not perfect. The purple stripes in the heatmap might correspond
to an outlier that could potentially be removed. We produce the same heatmap again with the sample identifiers as row names in order to see whether the outliers in the heatmap are the same ones as the outliers in the RLE plot beforehand: 

```{r alternativeHeatmapWithPatientProbesAsLabels, fig.height = 8.5, eval = TRUE}

rownames(dists) <- row.names(pData(palmieri_eset_norm))
hmcol <- colorRampPalette(brewer.pal(9, "PuOr"))(255)
colnames(dists) <- NULL
diag(dists) <- NA

pheatmap(dists, col = (hmcol), legend=TRUE, legend_breaks=c(min(dists, na.rm=TRUE), max(dists, na.rm=TRUE)), legend_labels=(c("low difference", "high difference")))

```
<!-- SR: evtl too much; sollen wir das machen oder rauslassen? -->
The outliers that could be found here are 2826_II, 3262_II, 3271_I, 2978_II and 3332_II. 
2826_II, 3262_II and 3332_II were found to be outliers in both RLE and heatmap and will therefore be removed.
Note that more elaborate metrics to identify and remove outliers are provided by the `r Biocpkg("arrayQualityMetrics") `.

```{r filteringOfOutliers}
palmieri_eset_filtered <- palmieri_eset_norm[, c(1:17, 19:43, 45:53, 55:58)]
```
<!--SR: quick and dirty Methode zum Filtern, weil ich auf Anhieb keine Möglichkeit gefunden habe, column names aus dem ExpressionSet auszuschließen. Möchten wir die drei Samples überhaupt ausschließen, oder geht das zu weit? NOTE: der Rest des Workflows läuft bis jetzt noch mit dem nicht gefilterten "palmieri_eset_norm" --> 

## Filtering based on intensity 

We now filter out lowly expressed genes. Microarray data commonly show a large number
of probes in the background intensity range. They also do not change much across arrays. 
Hence they combine a low variance with a low intensity. Thus, they could end up being detected as differentially expressed although they are barely above the "detection" limit 
and are not very informative in general. We will perform
a "soft" intensity based filtering here, since this is recommended by `r Biocpkg("limma")`'s 
[@limma; @Smyth_2004] user guide (a package we will use below for the differential 
expression analysis). However, note that 
a variance based filter might exclude a similar
set of probes in practice. 
In the histogram of the gene--wise medians, we 
can clearly see an enrichment of low medians on the left hand side. 
These represent the genes we want to filter. 

In order to infer a cutoff from the data, we inspect the histogram of the median intensities. We visually set a cutoff line to the left of the histogram peak as `man_threshold`, in order to not exclude too many genes. Transcripts that don't have intensities over the threshold in at least as many arrays as the smallest experimental group are excluded. 

In order to do so, we first have to get a list with the number of samples (`no_of_samples`) in the experimental groups: 

```{r expGroups, dependson="PCAMetricsCalibrated"}
no_of_samples <- table(paste0(Biobase::pData(palmieri_eset_norm)$Factor.Value.disease., "_", 
                        Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.))
no_of_samples 
```
Now, we calculate the row--wise medians from the expression data, as they represent the transcript medians, and assign them to `palmieri_medians`. We plot the histogram:

```{r alternativeIntensityBasedFilteringManuallyFiltered, fig.cap="Histogram of the median intensities per gene"}
palmieri_medians <- rowMedians(exprs(palmieri_eset_norm))

hist_res <- hist(palmieri_medians, 100, col="cornsilk1", freq = FALSE, 
            main = "Histogram of the median intensities", border="antiquewhite4",
            xlab = "Median intensities")
```

We inspect the histogram and set a manual threshold visually. In our example, we choose a threshold of 4. We plot the same histogram as before and add the threshold line with the `abline()` function. 

```{r setManualThreshold}
man_threshold <- 4

hist_res <- hist(palmieri_medians, 100, col="cornsilk", freq = FALSE, 
            main = "Histogram of the median intensities", border="antiquewhite4",
            xlab = "Median intensities")

abline(v=man_threshold, col="coral4", lwd=2)

```
When we are content with the manual threshold, we filter out all transcripts that don't have intensities over the threshold in at least as many arrays as the smallest experimental group, represented by `min(no_of_samples)`, which we define as `samples_cutoff`. We write a function `idx_man_threshold` that is applied to each row, that is to each transcript across all arrays. It evaluates whether the number of entries that is bigger than man_threshold (`sum(x>man_threshold)`) is bigger than the `samples_cutoff`and gives out TRUE or FALSE for each row, i.e. each transcript. 
We than create a table of idx_man_threshold in order to summarize the results, in order to get an overview over how many genes are filtered out. 
In the last step, we subset our expression set and keep the TRUE elements of `idx_man_threshold`.

```{r filteringOfLowIntensity_transcripts}
samples_cutoff <- min(no_of_samples)

idx_man_threshold <- apply(exprs(palmieri_eset_norm), 1, function(x){
  sum(x > man_threshold) >= samples_cutoff})
table(idx_man_threshold)

palmieri_manfiltered <- subset(palmieri_eset_norm, idx_man_threshold)
```


## Annotation of the transcript clusters

Before we continue with the linear models for microarrays and differential
expression,  we  describe how to add "feature Data", i.e. annotation
information to the transcript cluster identifiers stored in the featureData of
our ExpressionSet. We use the function `select`
from `r Biocpkg("AnnotationDbi") ` to query the gene symbols and associated
short descriptions for the transcript clusters. For each cluster, we add the 
gene symbol and a short description of the gene the cluster represents. 

In a second step, we directly filter out the probes that don't map to a gene, that is that don't have a gene symbol assigned. 

```{r annotateData, eval=TRUE, dependson="intensityBasedFiltering", message = FALSE}

anno_palmieri  <- AnnotationDbi::select(hugene10sttranscriptcluster.db,
                                  keys=(featureNames(palmieri_manfiltered)),
                                  columns = c("SYMBOL", "GENENAME"),
                                  keytype="PROBEID")

anno_palmieri <- subset(anno_palmieri, !is.na(SYMBOL))
```


## Removing multiple mappings and building custom annotations

Many transcript--cluster identifiers will map to multiple gene symbols, i.e. they can't be clearly assigned.

We compute a summary table in the code below to see how many there are. First, we group anno_palmieri for their PROBEID; that way, the subsequent operations aren't carried through for each single row, but for each group, that is each PROBEID.
We then summarize the groups and indicate the number of different genes assigned to a probe in the column `no_of_matches`. 
Now, we filter for PROBEIDs with multiple matches, that is when `no_of_matches > 1`.

With `dim(probe_stats)`, we can see how many probes have been mapped to multiple genes.

```{r multipleMappings, dependson="annotateData"}

anno_grouped <- group_by(anno_palmieri, PROBEID)
anno_summarized <- dplyr::summarize(anno_grouped, no_of_matches = n_distinct(SYMBOL))
anno_filtered <- filter(anno_summarized, no_of_matches > 1)

probe_stats <- anno_filtered 

dim(probe_stats)
```


We have close to 2000 transcript clusters that map to multiple gene symbols.
It is difficult to decide which mapping is "correct". Therefore,
we exclude these transcript clusters. 

We want to remove those probe IDs that match the ones in `probe_stats`, as those are the probes with multiple mappings. We assign these IDs to the variable `ids_to_exclude`. Then, we generate `palmieri_final`, an expression set without the `ids_to_exclude`. 

As we have just excluded probe IDs from the assay data, we now have to also exclude them from the feature data `anno_palmieri`. Recall that fData enables us to access the feature data of an expression set. Until now, no feature data whatsoever is stored in the `fData(palmieri_final)`. Only the row names are named as the row names of the assay data by default, which are the PROBEIDs of the transcripts. <!-- SR: is that true? or why are the row names already there even though we haven't done anything yet? -->
Therefore, we generate a column PROBEID in `fData(palmieri_final)` and assign the row names of `fData(palmieri_final)` to it. Then, we left--join `fData(palmieri_final)`with `anno_palmieri`, which already contains the columns "SYMBOL" and "GENENAME".
A left-join keeps the rows and columns of the first argument and adds the corresponding column entries of the second argument.
By left--joining with anno_palmieri, we thus add the "SYMBOL" and "GENENAME" columns from anno_palmieri for only the PROBEIDs that have been in `fData(palmieri_final)` before the left--joint and thus get the feature Data for the filtered probes.


```{r excludeMultipleMappings, dependson="multipleMappings"}
ids_to_exlude <- (featureNames(palmieri_manfiltered) %in% probe_stats$PROBEID)

table(ids_to_exlude)

palmieri_final <- subset(palmieri_manfiltered, !ids_to_exlude)

validObject(palmieri_final)

fData(palmieri_final)$PROBEID <- rownames(fData(palmieri_final))
fData(palmieri_final)<- left_join(fData(palmieri_final), anno_palmieri)


# restore rownames after left_join
rownames(fData(palmieri_final)) <-fData(palmieri_final)$PROBEID 
    
validObject(palmieri_final)
```


Alternatively, one can re--map the probes of the array
to a current annotation, a workflow to do this for Illumina arrays is given in
@Arloth_2015.
Essentially, the individual probe sequences are re--aligned to an in--silico
"exome" that consists of all annotated transcript exons.

In any case, the package `r Biocpkg("pdInfoBuilder") ` can be used to build custom
annotation packages for use with `r Biocpkg("oligo") `. In order to do this,
PGF / CLF files  (called "Library files" on the Affymetrix website) as well
as the probeset annotations are required. The probesets typically represent
small stretches of the genome (such as a single exon) and multiple probesets
are then used to form a transcript cluster.

The CLF file contains information about the location of
individual probes on the array. The PGF file then contains the individual probe
sequences and shows the probeset they belong to. Finally, The probeset annotation .csv
then contains information about which probesets are used
in which transcript cluster. Commonly, multiple probesets are used in one
transcript cluster and some probesets are contained in multiple transcript
clusters.


# A short overview of linear models
I am afraid this section is rather technical. However general experience shows that
most questions on the  Bioconductor support site about packages using using linear models
like `r Biocpkg("limma") ` [@limma],  `r Biocpkg("DESeq2")` [@Love_2014] and 
`r Biocpkg("edgeR") ` [@Robinson_2009] are actually
not so much about the packages themselves but rather about the underlying linear
models. It might also be helpful to learn a bit of linear algebra to understand
the concepts better. The Khan Academy [offers nice (and free) online courses](https://www.khanacademy.org/math/linear-algebra).
Mike Love's and Michael Irizzary's [genomics class](http://genomicsclass.github.io/book/)
is also a very good resource, especially its section on [interactions and contrasts](http://genomicsclass.github.io/book/pages/interactions_and_contrasts.html).

# Linear models for microarrays

We now apply linear models to microarrays. Specifically, we discuss
how to use the `r Biocpkg("limma") ` for differential expression analysis.
The package is designed to analyze complex experiments involving comparisons between
many experimental groups simultaneously while remaining reasonably easy to use
for simple experiments. The main idea is to fit a linear model to the expression 
data for each gene. Empirical Bayes and other shrinkage methods are used to borrow information
across genes for the residual variance estimation leading to a "moderated" \(t\)--statistics, 
and stabilizing the analysis for experiments 
with just a small number of arrays [@Smyth_2004].

In the following, we use appropriate design and contrast matrices for
our linear models and fit a linear model to each gene separately.

## A linear model for the data

The original paper is interested in changes in transcription that occur
between inflamed and adjacent non--inflamed mucosal areas of the colon.
This is studied in both inflammatory bowel disease types.

Since we have two arrays per individual, the first factor we need
is a blocking factor for the individuals that will absorb differences between
them. Then we create a factors that give us the grouping for the diseases and
the tissue types. We furthermore simplify the names of the
diseases to UC and DC, respectively. Then, we create two design matrices, 
one for each of the two diseases
as we will analyze them separately in order to follow the  analysis 
strategy of the original paper closely (one could also fit a joint model to 
the complete data set, however, the two diseases might behave very differently 
so that a joint fit might not be appropriate).

```{r createDesign, eval=TRUE, dependson="excludeMultipleMappings" }
individual <- as.character(Biobase::pData(palmieri_final)$Characteristics.individual.)

tissue <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.phenotype., " ", "_")
tissue <- ifelse(tissue == "non-inflamed_colonic_mucosa", "nI", "I")

disease <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.disease., " ", "_")
disease <- ifelse(disease == "Crohn's_disease", "CD", "UC")

#muss man disease und tissue nicht noch als factor umwandeln? also z.B.
#disease <- factor(disease)


i <- individual[disease == "CD"]
design_palmieri_CD <- model.matrix(~ 0  + tissue[disease == "CD"] + i)
colnames(design_palmieri_CD)[1:2] <- c("I", "nI")
#SR question: look at output matrix. How is it possible that the first two rows don't correspond to any of the individuals? that is, why is ID 164 not listed?

i <- individual[disease == "UC"]
design_palmieri_UC<- model.matrix(~ 0  + tissue[disease == "UC"] + i)
colnames(design_palmieri_UC)[1:2] <- c("I", "nI")

```

We can inspect the design matrices and test their rank.

```{r inspectDesignMatrix, eval = TRUE, dependson="createDesign"}
head(design_palmieri_CD[, 1:6])
dim(design_palmieri_CD)
min(svd(design_palmieri_CD)$d)

head(design_palmieri_UC[, 1:6])
dim(design_palmieri_UC)
min(svd(design_palmieri_UC)$d)
```


## Contrasts and hypotheses tests

We  now fit the linear models and
define appropriate contrasts to test hypotheses of interest.
We want to compare the inflamed  to the the non--inflamed tissue.
Thus, we create a contrast matrix consisting of one row. `r Biocpkg("limma")` 's function
`makeContrasts` creates this matrix from a synbolic description of the contrast of
interest. We can fit the linear model, compute the moderated \(t\)--statistics
by calling the ` eBayes ` function and finally extract the number of
differentially expressed genes while controlling the FDR by
requiring BH--corrected p--value below a certain threshold.

```{r createContrastMatrixAndFitModel, eval=TRUE, dependson="createDesign" }
contrast_matrix_CD <- makeContrasts(I-nI, levels = design_palmieri_CD)

palmieri_fit_CD <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "CD"],
                                design = design_palmieri_CD),
                                contrast_matrix_CD))

contrast_matrix_UC <- makeContrasts(I-nI, levels = design_palmieri_UC)

palmieri_fit_UC <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "UC"],
                                design = design_palmieri_UC),
                                contrast_matrix_UC))
```

## Extracting results

Results can be extracted by use of the `topTable` function. We extract
the comparisons for both Crohn's disease  as well as ulcerative colitis and
sort the results by their absolute \(t\)--statistics. As a diagnostic check, we also
plot the  p--value histogram: We expect a uniform distribution for the
p--values that correspond to true null hypotheses, while the a peak near zero
shows a enrichment for low p--values corresponding to differentially expressed (DE)
genes.  A p--value less than 0.001 was used in the original paper as a significance
cutoff leading to 298 (CD) and 520 (UC) DE--genes for the two diseases.

We call around 500/1000 genes in the two conditions at the same cutoff, this 
higher number of DE genes identified is probably
due to the increased power from the blocking according to the individuals
and the moderated variance estimation that `r Biocpkg("limma") ` performs.

```{r extractResultsC, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for Crohn’s disease."}
table_CD <-  topTable(palmieri_fit_CD, number = Inf)
head(table_CD)

table(table_CD$adj.P.Val < 0.05)

table(table_CD$P.Value < 0.001)

hist(table_CD$P.Value, col = brewer.pal(3, name = "Set2")[1],
     main = "inflamed vs non-inflamed - Crohn's disease", xlab = "p-values")
```


```{r extractResultsU, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for ulcerative colitis."}


table_UC <-  topTable(palmieri_fit_UC, number = Inf)
head(table_UC)

table(table_UC$adj.P.Val < 0.05)

table(table_UC$P.Value < 0.001)

hist(table_UC$P.Value, col = brewer.pal(3, name = "Set2")[2],
     main = "inflamed vs non-inflamed - Ulcerative colitis", xlab = "p-values")


```




## Comparison to the paper results

We now compare our list of differentially expressed genes to the results obtained
in the paper. The paper results can be downloaded as excel files  from
[http://links.lww.com/IBD/A795](http://links.lww.com/IBD/A795). We save it 
in an .xlsx file named `palmieri_DE_res.xlsx`. The paper results are  given
as identified differentially expressed genes
with a p--value less than 0.001, which corresponds to an FDR of 0.05 in Crohn's
disease and 0.02 in ulcerative colitis. There are four tables in total giving
the list of up and downregulated genes in CD and UC respectively.
In the code below, we extract the gene symbols from the excel table and then
compare them to the differentially expressed genes we identify at a p--value
of 0.001.


```{r compareDEgenes, dependson="extractResults"}
fpath <- system.file("extdata", "palmieri_DE_res.xlsx", package="maEndToEnd")
palmieri_DE_res <- sapply(1:4, function(i) read.xlsx(cols = 1, fpath, 
                                                     sheet = i, startRow = 4))

names(palmieri_DE_res) <- c("CD_UP", "CD_DOWN", "UC_UP", "UC_DOWN")
palmieri_DE_res <- lapply(palmieri_DE_res, as.character)
paper_DE_genes_CD <- Reduce("c", palmieri_DE_res[1:2])
paper_DE_genes_UC <- Reduce("c", palmieri_DE_res[3:4])

overlap_CD <- length(intersect(subset(table_CD, P.Value < 0.001)$SYMBOL,  
                               paper_DE_genes_CD)) / length(paper_DE_genes_CD)


overlap_UC <- length(intersect(subset(table_UC, P.Value < 0.001)$SYMBOL,
                               paper_DE_genes_UC)) / length(paper_DE_genes_UC)
overlap_CD
overlap_UC 

#add total number of genes found with our method
total_genenumber_CD <- length(subset(table_CD, P.Value < 0.001)$SYMBOL)
total_genenumber_UC <- length(subset(table_UC, P.Value < 0.001)$SYMBOL)

total_genenumber_CD
total_genenumber_UC


```


We see that we get a moderate overlap of `r overlap_CD` for CD and
`r overlap_UC` for UC. Note that is recommended to always to choose an
FDR cutoff instead of a p--value cutoff, since this way you control an
explicitly defined error rate and the results are easier to interpret and
to compare. In what follows, we choose an FDR cutoff of 10\%.


# Gene ontology (GO) based enrichment analysis

We can now try characterize the identified differentially expressed genes
a bit better by performing an GO enrichment analysis. Essentially the
gene ontology ([http://www.geneontology.org/](http://www.geneontology.org/)) is 
a hierarchically organized
collection of functional gene sets [@Ashburner_2000, @GO_2015, @du_Plessis_2011]. 


## Matching the background set of genes

The function ` genefinder ` from the `r Biocpkg("genefilter") ` package [@Bourgon_2010] 
will be used to find a background set of genes that are similar in expression 
to the differentially expressed genes. We then check whether 
the background has roughly the same distribution
of average expression strength as the foreground.

We do this in order not to select a biased background since the gene set testing
is performed by a simple Fisher test on a 2x2 table. Note that this approach
is very similar to commonly used web tools like GOrilla [@Eden_2009]. 
Here we focus on the  CD subset of the  data.

For every differentially expressed gene, we try to find genes with similar
expression.

```{r GOAnalysisCreateBackgrounds, eval=TRUE, fig.cap="Selecting a background set of genes for the gene ontology analysis.", warning=FALSE, message=FALSE}
DE_genes_CD <- subset(table_CD, adj.P.Val < 0.1)$PROBEID

back_genes_idx <- genefinder(palmieri_final, as.character(DE_genes_CD), 
                       method="manhattan", scale="none")

back_genes_idx <- sapply(back_genes_idx, function(x)x$indices)

back_genes <-featureNames(palmieri_final)[back_genes_idx]
back_genes <- setdiff(back_genes, DE_genes_CD)

    
intersect(back_genes, DE_genes_CD)
length(back_genes)

multidensity(list(
        all=  table_CD[,"AveExpr"] ,
        fore= table_CD[DE_genes_CD , "AveExpr"],
        back= table_CD[rownames(table_CD) %in% back_genes, "AveExpr"]),
        col = c("#e46981", "#ae7ee2", "#a7ad4a"),
     xlab="mean expression",
   main = "DE genes for CD - background - matching")
```

We can see that the matching returned a sensible result and can now
perform the actual testing. For this purpose we use the `r Biocpkg("topGO") ` which
implements a nice interface to Fisher testing and also has additional algorithms
taking the GO structure into account, by e.g. only reporting the most specific
gene set in the hierarchy [@Alexa_2006].

The GO has three top ontologies, cellular component (CC), biological  processes
(BP), and molecular function (MF). For illustrative purposes we limit ourselves 
to the BP category here. 

## Running topGO

We first create a factor `all_genes` which indicates for every gene in
our background / universe, whether it is differentially expressed or not.

```{r createFactorOfInterestingGenes, dependson="GOAnalysisCreateBackgrounds", eval=TRUE}
gene_IDs <- rownames(table_CD)
in_universe <- gene_IDs %in% c(DE_genes_CD ,  back_genes)
inSelection <-  gene_IDs %in% DE_genes_CD 
all_genes <- factor(as.integer(inSelection[in_universe]))
names(all_genes) <- gene_IDs[in_universe]
```

We now initialize the `r Biocpkg("topGO") ` data set, using the GO annotations 
contained
in the annotation data base for the chip we are using. The `nodeSize`
parameter specifies a minimum size of a GO category we want to use: i.e. here
categories with less than 10 genes are not included in the testing.

```{r createTopGODataSet, dependson="createFactorOfInterestingGenes", eval=TRUE, message = FALSE }
ont <- "BP"

top_GO_data <- new("topGOdata", ontology = ont, allGenes = all_genes,
 nodeSize = 10, annot=annFUN.db, affyLib = "hugene10sttranscriptcluster.db")
```

Now the tests can be run. `r Biocpkg("topGO") ` offers a wide range of options,
for details see the paper or the package vignette.

We run two common tests: an ordinary Fisher test for every GO category, and the
"elim" algorithm, which tries to incorporate the hierarchical structure of the
GO and tries "decorrelate" it in order to report the most specific significant 
term in the hierarchy.

The algorithm starts processing the nodes/GO categories
from the highest (bottommost) level and then iteratively
moves to nodes from a lower level. If a node is scored as significant,
all of its genes  are marked as removed in all ancestor nodes.
This way, the "elim" algorithm aims at finding the most specific node
for every gene.

The tests uses a 0.01 p--value cutoff by default.

```{r runtopGOTests, results='hide', eval=TRUE, dependson = "createTopGODataSet",  message = FALSE}
result_top_GO_elim <- runTest(top_GO_data, algorithm = "elim", statistic = "Fisher")
result_top_GO_classic <- runTest(top_GO_data, algorithm = "classic", statistic = "Fisher")
```

We can now inspect the results.  We look at the top 100 GO categories according
to the "Fisher elim" algorithm. The function `GenTable` produces
a table of significant GO categories, the function `printGenes`
gives significant genes annotated to them.

```{r processtopGOResults, eval=TRUE, dependson="runtopGOTests"}
res_top_GO <- GenTable(top_GO_data, Fisher.elim = result_top_GO_elim,
        Fisher.classic = result_top_GO_classic,
        orderBy = "Fisher.elim" , topNodes = 100)

genes_top_GO <- printGenes(top_GO_data, whichTerms = res_top_GO$GO.ID,
    chip = "hugene10sttranscriptcluster.db", geneCutOff = 1000)

res_top_GO$sig_genes <- sapply(genes_top_GO, function(x){
                str_c(paste0(x[x$'raw p-value' == 2, "Symbol.id"],";"), collapse = "")
    })

head(res_top_GO[,1:8], 20)
```

## Visualization of the GO--analysis results

A graph of the results can also be produced. Here we visualize the three most
significant nodes according to the Fisher elim algorithm in the context of
the GO hierarchy.

```{r  graphOfResults, fig.height = 6, eval=TRUE, fig.cap = "A graphical representation of the topGO results.", results='hide'}
showSigOfNodes(top_GO_data, score(result_top_GO_elim), firstSigNodes = 3,
               useInfo = 'def')
```

We can see that indeed GO categories related to inflammation, signalling and 
immune response show up as significant.
Gene set enrichment analysis has been  a field of very extensive
research in bioinformatics. For additional approaches see the `r Biocpkg("topGO") `
vignette and the references therein and also in the [GeneSetEnrichment view](http://bioconductor.org/packages/release/BiocViews.html#___GeneSetEnrichment). 


# A pathway enrichment analysis using reactome

The package `r Biocpkg("ReactomePA") ` offers the possibility to test enrichment
of specific pathways using the free, open-source, curated and peer reviewed 
pathway [Reactome](http://www.reactome.org/s) pathway database [@Croft_2013; @Fabregat_2015]. 
The package requires entrez identifiers, so we convert our PROBEIDs (trancript cluster identifiers) 
to entrez identifiers using the function `mapIDs` from  the package `r Biocpkg("AnnotationDbi")`. 
This will create a named vector that maps the PROBEIDs to the entrez ones.


```{r mapIDsToEntrez, dependson="createFactorOfInterestingGenes", message = FALSE}
entrez_ids <- mapIds(hugene10sttranscriptcluster.db, 
      keys = rownames(table_CD), 
      keytype="PROBEID",
      column = "ENTREZID")
```


We can now run the enrichment analysis that performs a statistical test
based on the hypergeoemtric distribution that is the same as a one sided Fisher--test, 
which `r Biocpkg("topGO")` calls "Fisher--classic".
Details can be found in the vignette of the `r Biocpkg("DOSE")` package [@Yu_2014].

```{r runReactomeEnrichment, fig.cap="Enriched Reactome pathways and their p–values as a bar chart.", eval = TRUE}
reactome_enrich <- enrichPathway(gene = entrez_ids[DE_genes_CD], 
                                universe = entrez_ids[c(DE_genes_CD, 
                                                        back_genes)],
                                organism = "human",
                                pvalueCutoff = 0.05,
                                qvalueCutoff = 0.9, 
                                readable = TRUE)

reactome_enrich@result$Description <- paste0(str_sub(
                                    reactome_enrich@result$Description, 1, 20),
                                    "...")

head(summary(reactome_enrich))[1:6]
```

Note that we trimmed pathway names to 20 characters.

## Visualizing the reactome based analysis results 

The `r Biocpkg("reactomePA") ` package offers nice visualization capabilities.
The top pathways can be displayed as a bar char that displays all categories
with a p--value below the specified cutoff.

```{r reactomeBar, dependson="runReactomeEnrichment", fig.cap="Enriched Reactome pathways and their p–values as a bar chart."}
barplot(reactome_enrich)
```

The "enrichment map" displays the results of the enrichment analysis as 
a graph, where the color represents the p--value of the pathway and the
edge--thickness is proportional to the number of overlapping genes between
two pathways.

```{r enrichMap, dependson="runReactomeEnrichment", fig.width=6, fig.height = 7, fig.cap="Enriched Reactome pathways enrichment results as a graph."}
#enrichMap(reactome_enrich, n = 10, vertex.label.font = 2)

emapplot(reactome_enrich, showCategory=10)
```

Again, the graph in Figure \@ref(fig:enrichMap) shows pathways related to  signalling and immune response. 

The package `r Biocpkg("clusterProfiler") ` [@Yu_2012] can also perform these analyses 
using downloaded KEGG data. Furthermore, the package `r Biocpkg("EnrichmentBrowser") `
[@Geistlinger_2016] additionally offers network--based enrichment analysis of individual 
pathways. This allows the mapping of the expression data at hand to known
regulatory interactions.


# Session information

As the last part of this document, we call the function *sessionInfo*,
which reports the version numbers of R and all the packages used in
this session. It is good practice to always keep such a record of this
as it will help to track down what has happened in case an R script
ceases to work or gives different results because the functions have
been changed in a newer version of one of your packages. By including
it at the bottom of a script, your reports will become more reproducible.

The session information should also *always*
be included in any emails to the
[Bioconductor support site](https://support.bioconductor.org) along
with all code used in the analysis.

```{r, include=FALSE}
## clean up to improve build stability
gc()
```

```{r}
sessionInfo()
```


# Acknowledgements

The author would like to thank Vladislava Milchevskaya. Julian Gehring and Mike Smith for 
helpful comments on and small contributions to the workflow. 
This workflow draws a lot of inspiration from  the Bioconductor 
books [@Bioc2005, @useRbook2008] as well as Love et. al.'s  workflow 
for gene level analysis of RNA--Seq data [@Love_2015]. James W. MacDonald 
provided valuable information on the evolution of Affymetrix arrays in some of 
his posts of on the Biocondctor mailing list/support site. 
The author would also like to thank him for some friendly personal 
correspondence about the annotation resources available
for microarrays in Bioconductor.

<!--
Dan Tenenbaum provided helpful technical support on the bioconductor
workflow system. 
-->

# References

